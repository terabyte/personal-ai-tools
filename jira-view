#!/usr/bin/env python3

"""
Jira Viewer - View tickets or query results with interactive TUI
Usage: jira-view TICKET-123           # View a single ticket
       jira-view "JQL query"          # Interactive TUI with vim keybindings
"""

import argparse
import json
import os
import re
import subprocess
import sys
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Tuple

from jira_utils import JiraUtils
from jira_tui import JiraTUI


class JiraViewer:
    def __init__(self):
        self.script_dir = Path(__file__).parent
        self.utils = JiraUtils(self.script_dir)

    def is_ticket_key(self, arg: str) -> bool:
        """Check if argument looks like a ticket key (PROJECT-123)."""
        return bool(re.match(r'^[A-Z][A-Z0-9]+-\d+$', arg))

    def fetch_ticket_details(self, ticket_key: str) -> Optional[dict]:
        """Fetch full ticket details including comments and history."""
        fields = [
            'key', 'summary', 'description', 'status', 'priority', 'assignee',
            'reporter', 'created', 'updated', 'resolutiondate', 'duedate',
            'issuetype', 'labels', 'components', 'fixVersions', 'comment',
            'customfield_10061',  # Story points
            'customfield_10021',  # Sprint
            'customfield_10023',  # Flags
            'parent',  # Parent issue for subtasks
            'issuelinks',  # Linked issues
            'resolution'  # Resolution (for closed tickets)
        ]
        fields_str = ','.join(fields)

        # Get ticket with comments
        endpoint = f"/issue/{ticket_key}?fields={fields_str}&expand=changelog"
        response = self.utils.call_jira_api(endpoint)

        return response

    def format_description_lines(self, description_obj, indent: str = "  ") -> List[Tuple[str, str]]:
        """Format Jira ADF description to tagged lines for TUI rendering.

        Returns list of (tag, text) tuples where tag indicates styling.
        Tags: CODE for code block lines, empty string for normal text.
        """
        if not description_obj:
            return [("", f"{indent}(No description)")]

        lines = []

        def extract_text_inline(node):
            """Extract plain text from inline ADF node."""
            if isinstance(node, str):
                return node
            if not isinstance(node, dict):
                return ""
            text_value = node.get('text', '')
            if text_value:
                return text_value
            content = node.get('content', [])
            return ''.join(extract_text_inline(c) for c in content)

        def process_node(node):
            """Process ADF nodes into (tag, text) tuples."""
            if not isinstance(node, dict):
                return []

            node_type = node.get('type')
            content = node.get('content', [])

            if node_type == 'doc':
                result = []
                for c in content:
                    result.extend(process_node(c))
                return result

            elif node_type == 'paragraph':
                para_text = ''.join(extract_text_inline(c) for c in content)
                if para_text.strip():
                    return [("", f"{indent}{para_text}")]
                return []

            elif node_type == 'codeBlock':
                # Extract code text and split into lines
                code_text = ''.join(extract_text_inline(c) for c in content)
                code_lines = code_text.split('\n')
                result = []
                line_num_width = len(str(len(code_lines)))
                for line_no, line in enumerate(code_lines, 1):
                    # Add line number prefix and CODE tag
                    prefix = f"{line_no:>{line_num_width}} "
                    result.append(("CODE", f"{indent}{prefix}{line}"))
                return result

            elif node_type == 'bulletList':
                result = []
                for item in content:
                    if item.get('type') == 'listItem':
                        item_content = item.get('content', [])
                        for ic in item_content:
                            if ic.get('type') == 'paragraph':
                                item_text = ''.join(extract_text_inline(c) for c in ic.get('content', []))
                                if item_text.strip():
                                    result.append(("", f"{indent}  • {item_text}"))
                return result

            elif node_type == 'orderedList':
                result = []
                for i, item in enumerate(content, 1):
                    if item.get('type') == 'listItem':
                        item_content = item.get('content', [])
                        for ic in item_content:
                            if ic.get('type') == 'paragraph':
                                item_text = ''.join(extract_text_inline(c) for c in ic.get('content', []))
                                if item_text.strip():
                                    result.append(("", f"{indent}  {i}. {item_text}"))
                return result

            else:
                # Default: recursively process content
                result = []
                for c in content:
                    result.extend(process_node(c))
                return result

        # Process the description
        lines = process_node(description_obj)
        return lines if lines else [("", f"{indent}(No description)")]

    def format_description(self, description_obj, use_colors: bool, indent: str = "  ") -> str:
        """Format Jira ADF (Atlassian Document Format) description to readable text."""
        if not description_obj:
            return f"{indent}(No description)"

        def extract_text(node) -> str:
            """Recursively extract text from ADF node."""
            if isinstance(node, str):
                return node

            if isinstance(node, dict):
                node_type = node.get('type')
                content = node.get('content', [])
                text_value = node.get('text', '')

                # Handle marks (bold, italic, code, etc)
                marks = node.get('marks', [])
                has_code = any(m.get('type') == 'code' for m in marks)

                if text_value:
                    if has_code and use_colors:
                        return f'\033[36m`{text_value}`\033[0m'
                    return text_value

                # Handle different node types
                if node_type == 'paragraph':
                    return ''.join(extract_text(c) for c in content)
                elif node_type == 'heading':
                    level = node.get('attrs', {}).get('level', 1)
                    heading_text = ''.join(extract_text(c) for c in content)
                    if use_colors:
                        return f'\033[1;34m{"#" * level} {heading_text}\033[0m'
                    return f'{"#" * level} {heading_text}'
                elif node_type == 'bulletList':
                    items = []
                    for item in content:
                        item_text = extract_text(item)
                        if item_text:
                            items.append(f'{indent}  • {item_text}')
                    return '\n'.join(items)
                elif node_type == 'orderedList':
                    items = []
                    for i, item in enumerate(content, 1):
                        item_text = extract_text(item)
                        if item_text:
                            items.append(f'{indent}  {i}. {item_text}')
                    return '\n'.join(items)
                elif node_type == 'listItem':
                    return ''.join(extract_text(c) for c in content)
                elif node_type == 'codeBlock':
                    code_text = ''.join(extract_text(c) for c in content)
                    if use_colors:
                        return f'\033[90m{indent}  {code_text}\033[0m'
                    return f'{indent}  {code_text}'
                elif node_type == 'hardBreak':
                    return '\n'
                elif node_type == 'inlineCard':
                    url = node.get('attrs', {}).get('url', '')
                    return url
                elif node_type == 'doc':
                    lines = []
                    for c in content:
                        text = extract_text(c)
                        if text and text.strip():
                            # Add proper indentation to each line
                            for line in text.split('\n'):
                                if line.strip():
                                    lines.append(f'{indent}{line}')
                    return '\n'.join(lines)
                else:
                    # Default: just concatenate content
                    return ''.join(extract_text(c) for c in content)

            return ''

        result = extract_text(description_obj)
        return result if result.strip() else f"{indent}(No description)"

    def format_comment(self, comment: dict, use_colors: bool) -> str:
        """Format a single comment with author and timestamp."""
        author_data = comment.get('author', {})
        author_name = self.utils.get_assignee_name(author_data) or author_data.get('displayName', 'Unknown')

        created_str = comment.get('created', '')
        created_formatted = self.format_datetime(created_str)

        body = comment.get('body', {})
        body_text = self.format_description(body, use_colors, indent="    ")

        if use_colors:
            header = f'\033[1;33m  {author_name}\033[0m \033[90m({created_formatted})\033[0m'
        else:
            header = f'  {author_name} ({created_formatted})'

        return f'{header}\n{body_text}'

    def format_datetime(self, dt_str: str) -> str:
        """Format ISO datetime to readable format."""
        try:
            if dt_str.count(':') == 2 and ('+' in dt_str[-5:] or '-' in dt_str[-5:]):
                dt_str = dt_str[:-2] + ':' + dt_str[-2:]
            dt = datetime.fromisoformat(dt_str)
            return dt.strftime('%Y-%m-%d %H:%M')
        except:
            return dt_str

    def filter_recent_comments(self, comments: List[dict], days: int = 2, min_count: int = 10) -> List[dict]:
        """Filter comments to recent ones (last N days or minimum count)."""
        if not comments:
            return []

        threshold = datetime.now(timezone.utc) - timedelta(days=days)
        recent = []

        for comment in comments:
            created_str = comment.get('created', '')
            try:
                if created_str.count(':') == 2 and ('+' in created_str[-5:] or '-' in created_str[-5:]):
                    created_str = created_str[:-2] + ':' + created_str[-2:]
                created_dt = datetime.fromisoformat(created_str)
                if created_dt.astimezone(timezone.utc) >= threshold:
                    recent.append(comment)
            except:
                continue

        # If we don't have enough recent comments, return last N comments
        if len(recent) < min_count:
            return comments[-min_count:] if len(comments) >= min_count else comments

        return recent

    def format_history_entry(self, history_item: dict, use_colors: bool) -> List[str]:
        """Format a changelog history entry."""
        author_data = history_item.get('author', {})
        author_name = self.utils.get_assignee_name(author_data) or author_data.get('displayName', 'Unknown')

        created_str = history_item.get('created', '')
        created_formatted = self.format_datetime(created_str)

        items = history_item.get('items', [])
        if not items:
            return []

        lines = []
        if use_colors:
            header = f'\033[1;35m  {author_name}\033[0m \033[90m({created_formatted})\033[0m'
        else:
            header = f'  {author_name} ({created_formatted})'
        lines.append(header)

        for item in items:
            field = item.get('field', 'unknown')
            from_val = item.get('fromString', '(none)')
            to_val = item.get('toString', '(none)')

            if use_colors:
                lines.append(f'    \033[36m{field}\033[0m: {from_val} → {to_val}')
            else:
                lines.append(f'    {field}: {from_val} → {to_val}')

        return lines

    def format_ticket_detail_lines(self, ticket: dict, max_width: int = 1000) -> List[Tuple[str, str]]:
        """
        Format ticket details as tagged lines for rendering.
        Returns list of (tag, text) tuples where tag indicates styling.

        Tags: KEY, SUMMARY, STATUS_X, WARN, PRIORITY_X, DATE_X, HEADER, or empty string
        """
        fields = ticket.get('fields', {})
        key = ticket.get('key', 'N/A')

        lines = []

        # Header - Key and Summary
        summary = fields.get('summary', 'No summary')
        lines.append(("KEY", f" {key}"[:max_width - 2]))
        lines.append(("SUMMARY", f" {summary}"[:max_width - 2]))
        lines.append(("", ""))

        # Status
        status = fields.get('status', {}).get('name', 'Unknown')
        status_letter = self.utils.get_status_letter(status)
        lines.append((f"STATUS_{status_letter}", f" Status: {status}"[:max_width - 2]))

        # Resolution (show if present)
        resolution = fields.get('resolution')
        if resolution:
            resolution_name = resolution.get('name', 'Unknown')
            lines.append(("", f" Resolution: {resolution_name}"[:max_width - 2]))

        # Flags (show right under status if present)
        flags = fields.get('customfield_10023', [])
        if flags:
            flag_values = []
            for flag in flags:
                if isinstance(flag, dict):
                    flag_values.append(flag.get('value', str(flag)))
                else:
                    flag_values.append(str(flag))
            flags_str = ', '.join(flag_values)
            lines.append(("WARN", f" Flags: {flags_str}"[:max_width - 2]))

        # Type, Assignee, Reporter, Priority
        issue_type = fields.get('issuetype', {}).get('name', 'Unknown')
        lines.append(("", f" Type: {issue_type}"[:max_width - 2]))

        assignee = fields.get('assignee')
        assignee_name = self.utils.get_assignee_name(assignee) if assignee else 'Unassigned'
        lines.append(("", f" Assignee: {assignee_name}"[:max_width - 2]))

        reporter = fields.get('reporter')
        reporter_name = reporter.get('displayName', 'Unknown') if reporter else 'Unknown'
        lines.append(("", f" Reporter: {reporter_name}"[:max_width - 2]))

        priority = fields.get('priority', {}).get('name', 'None')
        lines.append((f"PRIORITY_{priority}", f" Priority: {priority}"[:max_width - 2]))

        # Dates with relative time
        created_str = fields.get('created', '')
        created_days, created_text = self.utils.calculate_days_since_update(created_str)
        created_formatted = self.format_datetime(created_str)
        created_color = '1' if created_days < 2 else '2' if created_days < 5 else '0'
        created_line = f" Created: {created_formatted}"
        if created_text:
            created_line += f" ({created_text})"
        lines.append((f"DATE_{created_color}", created_line[:max_width - 2]))

        updated_str = fields.get('updated', '')
        updated_days, updated_text = self.utils.calculate_days_since_update(updated_str)
        updated_formatted = self.format_datetime(updated_str)
        updated_color = '1' if updated_days < 2 else '2' if updated_days < 5 else '0'
        updated_line = f" Updated: {updated_formatted}"
        if updated_text:
            updated_line += f" ({updated_text})"
        lines.append((f"DATE_{updated_color}", updated_line[:max_width - 2]))

        # Labels
        labels = fields.get('labels', [])
        if labels:
            labels_str = ', '.join(labels)
            lines.append(("", f" Labels: {labels_str}"[:max_width - 2]))

        # Parent
        parent = fields.get('parent')
        if parent:
            parent_key = parent.get('key', 'Unknown')
            parent_summary = parent.get('fields', {}).get('summary', '')
            parent_text = f"{parent_key}: {parent_summary}" if parent_summary else parent_key
            lines.append(("", f" Parent: {parent_text}"[:max_width - 2]))

        return lines

    def render_tagged_lines(self, lines: List[Tuple[str, str]], use_colors: bool) -> None:
        """Render tagged lines with ANSI color codes."""
        for tag, text in lines:
            if not use_colors:
                print(text)
                continue

            # Map tags to ANSI colors
            if tag == "KEY":
                print(f'\033[1;32m{text}\033[0m')  # Bold green
            elif tag == "SUMMARY":
                print(f'\033[1m{text}\033[0m')  # Bold
            elif tag.startswith("STATUS_"):
                status_letter = tag.split("_")[1]
                if status_letter in ['C', 'V', 'Z', 'Y', 'M']:
                    print(f'\033[32m{text}\033[0m')  # Green for done
                elif status_letter in ['A', 'B', 'S', 'W']:
                    print(f'\033[34m{text}\033[0m')  # Blue for backlog
                elif status_letter in ['P', 'R', 'Q', 'T']:
                    print(f'\033[33m{text}\033[0m')  # Yellow for active
                elif status_letter in ['D', 'X', '_']:
                    print(f'\033[31m{text}\033[0m')  # Red for blocked
                else:
                    print(text)
            elif tag == "WARN":
                print(f'\033[31m{text}\033[0m')  # Red
            elif tag.startswith("PRIORITY_"):
                priority = tag.split("_", 1)[1]
                if priority in ['Critical', 'Blocker', 'Highest']:
                    print(f'\033[31m{text}\033[0m')  # Red
                elif priority in ['High']:
                    print(f'\033[33m{text}\033[0m')  # Yellow
                elif priority in ['Low', 'Lowest']:
                    print(f'\033[34m{text}\033[0m')  # Blue
                else:
                    print(text)
            elif tag.startswith("DATE_"):
                color_num = tag.split("_")[1]
                if color_num == '1':
                    print(f'\033[32m{text}\033[0m')  # Green (< 2 days)
                elif color_num == '2':
                    print(f'\033[33m{text}\033[0m')  # Yellow (2-5 days)
                else:
                    print(text)
            elif tag == "HEADER":
                print(f'\033[34m{text}\033[0m')  # Blue
            else:
                print(text)

    def display_ticket(self, ticket: dict, use_colors: bool, show_full: bool = False) -> None:
        """Display formatted ticket details."""
        # Use shared formatting logic
        detail_lines = self.format_ticket_detail_lines(ticket)
        self.render_tagged_lines(detail_lines, use_colors)
        print()

        # Description
        fields = ticket.get('fields', {})
        description = fields.get('description')
        if use_colors:
            print('\033[1;34m──── Description ────\033[0m')
        else:
            print('──── Description ────')
        print(self.format_description(description, use_colors))
        print()

        # Comments
        comments_data = fields.get('comment', {})
        all_comments = comments_data.get('comments', [])

        if all_comments:
            if show_full:
                comments_to_show = all_comments
                if use_colors:
                    print(f'\033[1;34m──── All Comments ({len(all_comments)}) ────\033[0m')
                else:
                    print(f'──── All Comments ({len(all_comments)}) ────')
            else:
                comments_to_show = self.filter_recent_comments(all_comments)
                if use_colors:
                    print(f'\033[1;34m──── Recent Comments ({len(comments_to_show)}/{len(all_comments)}) ────\033[0m')
                else:
                    print(f'──── Recent Comments ({len(comments_to_show)}/{len(all_comments)}) ────')

            for comment in comments_to_show:
                print(self.format_comment(comment, use_colors))
                print()
        else:
            if use_colors:
                print('\033[1;34m──── Comments ────\033[0m')
            else:
                print('──── Comments ────')
            print('  (No comments)')
            print()

        # History (only if --full)
        if show_full:
            changelog = ticket.get('changelog', {})
            histories = changelog.get('histories', [])

            if histories:
                if use_colors:
                    print(f'\033[1;34m──── Change History ({len(histories)}) ────\033[0m')
                else:
                    print(f'──── Change History ({len(histories)}) ────')

                for history in histories:
                    lines = self.format_history_entry(history, use_colors)
                    for line in lines:
                        print(line)
                    print()

    def display_jql_results(self, query: str, use_colors: bool) -> None:
        """Display JQL query results and allow selection."""
        # Fetch results
        fields = ['key', 'summary', 'status', 'priority', 'assignee', 'updated',
                  'customfield_10061', 'customfield_10021']

        print(f'Searching: {query}')
        print()

        issues = self.utils.fetch_all_jql_results(query, fields, max_items=100)

        if not issues:
            print('No results found.')
            # Provide helpful hints for common JQL syntax mistakes
            if '>' in query and 'd' in query and '-' not in query:
                print('\n💡 Tip: For relative dates in JQL, use negative values (e.g., "updated >= -2d" for last 2 days)')
            elif '<' in query and 'd' in query and '-' not in query:
                print('\n💡 Tip: For relative dates in JQL, use negative values (e.g., "created >= -7d" for last week)')
            return

        # Display list
        terminal_width = self.utils.get_terminal_width()
        summary_length = self.utils.calculate_summary_length(terminal_width, reserved_space=60)

        print(f'Found {len(issues)} tickets:\n')

        for idx, issue in enumerate(issues, 1):
            line = self.utils.format_ticket_line(issue, idx, summary_length, use_colors,
                                                  show_sprint=False, show_status=True)
            print(line)

        # Interactive selection
        print()
        try:
            selection = input('Enter ticket number to view (or press Enter to exit): ').strip()

            if not selection:
                return

            try:
                ticket_num = int(selection)
                if 1 <= ticket_num <= len(issues):
                    selected_issue = issues[ticket_num - 1]
                    selected_key = selected_issue.get('key')

                    print()
                    print('─' * 80)
                    print()

                    # Fetch and display full ticket
                    ticket = self.fetch_ticket_details(selected_key)
                    if ticket:
                        self.display_ticket(ticket, use_colors, show_full=False)
                else:
                    print(f'Invalid selection. Please enter a number between 1 and {len(issues)}.')
            except ValueError:
                print('Invalid input. Please enter a number.')
        except (KeyboardInterrupt, EOFError):
            print()
            return

    def run(self, args) -> int:
        """Main execution."""
        use_colors = self.utils.determine_colors(args)

        query_or_ticket = args.query_or_ticket

        # If --no-tui is specified, display tickets non-interactively
        if args.no_tui:
            # Determine if it's a ticket key or JQL query
            if self.is_ticket_key(query_or_ticket):
                # View single ticket
                ticket = self.fetch_ticket_details(query_or_ticket)
                if not ticket:
                    print(f'❌ Failed to fetch ticket: {query_or_ticket}', file=sys.stderr)
                    return 1

                self.display_ticket(ticket, use_colors, show_full=args.full)
            else:
                # JQL query - fetch and display all matching tickets
                fields = [
                    'key', 'summary', 'description', 'status', 'priority', 'assignee',
                    'reporter', 'created', 'updated', 'resolutiondate', 'duedate',
                    'issuetype', 'labels', 'components', 'fixVersions', 'comment',
                    'customfield_10061',  # Story points
                    'customfield_10021',  # Sprint
                    'customfield_10023',  # Flags
                    'parent'  # Parent issue for subtasks
                ]
                tickets = self.utils.fetch_all_jql_results(query_or_ticket, fields, expand='changelog')

                if not tickets:
                    print(f'❌ No tickets found matching query: {query_or_ticket}', file=sys.stderr)
                    return 1

                # Display each ticket sequentially
                for i, ticket in enumerate(tickets):
                    if i > 0:
                        print('\n' + '=' * 80 + '\n')
                    self.display_ticket(ticket, use_colors, show_full=args.full)

            return 0

        # Default: Always use interactive TUI
        tui = JiraTUI(self, use_colors)
        return tui.run(query_or_ticket)


def main():
    parser = argparse.ArgumentParser(
        description='View Jira tickets or query results with interactive TUI',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  jira-view CIPLAT-2250                                    # View ticket in TUI (default)
  jira-view "project=CIPLAT AND status='In Progress'"     # View query results in TUI
  jira-view CIPLAT-2250 --no-tui                          # View ticket non-interactively
  jira-view "project=CIPLAT" --no-tui --full              # View all tickets sequentially

Interactive TUI keybindings:
  j/k or ↓/↑   Move up/down in ticket list
  g/G          Jump to top/bottom
  v            Open current ticket in browser
  f            Toggle full mode (all comments)
  r            Refresh view
  /            Search/filter tickets
  ?            Show help
  q            Quit
        """
    )

    parser.add_argument('query_or_ticket', help='Ticket key (PROJECT-123) or JQL query')
    parser.add_argument('--full', action='store_true', help='Show all comments and change history')
    parser.add_argument('--no-tui', action='store_true', help='Disable interactive TUI, show tickets sequentially')
    parser.add_argument('-c', '--color', action='store_true', help='Force enable colors')
    parser.add_argument('--no-color', action='store_true', help='Force disable colors')

    args = parser.parse_args()

    viewer = JiraViewer()
    return viewer.run(args)


if __name__ == '__main__':
    sys.exit(main())
