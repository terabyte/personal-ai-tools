#!/usr/bin/env python3

"""
Backlog Cleanup - Show backlog items for triage and prioritization
Displays backlog tickets in rank order with status indicators
"""

import argparse
import os
import sys
from datetime import datetime
from pathlib import Path

from jira_utils import JiraUtils


class BacklogCleanup:
    def __init__(self):
        self.script_dir = Path(__file__).parent
        self.config_file = self.script_dir / "teams.conf"
        self.utils = JiraUtils(self.script_dir)

    def show_backlog(self, backlog_jql: str, count: int, summary_length: int, use_colors: bool) -> None:
        """Show backlog items separated by triage status."""
        print(f">> BACKLOG TRIAGE ({count} items)")
        print("=" * 40)

        self.utils.print_status_legend(use_colors, 'backlog')
        print()

        # Fetch all backlog items
        fields = ['key', 'summary', 'priority', 'created', 'assignee', 'customfield_10061',
                 'customfield_10022', 'status', 'updated', 'duedate', 'customfield_10021']
        all_issues = self.utils.fetch_all_jql_results(backlog_jql, fields)

        if not all_issues:
            print("   No backlog items found")
            return

        # Sort by rank first
        issues_sorted = self.utils.sort_by_rank(all_issues)

        # Separate by triage status and due dates
        triage_items, due_soon_items, other_items = self.utils.separate_by_triage_and_due_dates(issues_sorted, 30)

        # Display sections with proper counts
        items_shown = 0

        # Show triage items first
        if triage_items and items_shown < count:
            print("PENDING TRIAGE:")
            for issue in triage_items:
                if items_shown >= count:
                    break
                ticket_line = self.utils.format_ticket_line(issue, items_shown + 1, summary_length, use_colors, show_status=True)
                print(f'   {ticket_line}')
                items_shown += 1
            print()

        # Show due soon items second
        if due_soon_items and items_shown < count:
            print("DUE SOON (next 30 days):")
            for issue in due_soon_items:
                if items_shown >= count:
                    break
                ticket_line = self.utils.format_ticket_line(issue, items_shown + 1, summary_length, use_colors,
                                                          show_due_date_prefix=True, show_status=True)
                print(f'   {ticket_line}')
                items_shown += 1
            print()

        # Show other items
        if other_items and items_shown < count:
            remaining_slots = count - items_shown
            will_show = min(remaining_slots, len(other_items))
            total_other = len(other_items)

            print(f"OTHER BACKLOG ({will_show}/{total_other}):")
            for issue in other_items:
                if items_shown >= count:
                    break
                ticket_line = self.utils.format_ticket_line(issue, items_shown + 1, summary_length, use_colors, show_status=True)
                print(f'   {ticket_line}')
                items_shown += 1

        total_remaining = len(issues_sorted) - items_shown
        if total_remaining > 0:
            print(f'   ... and {total_remaining} more items in backlog')

    def run(self, args) -> None:
        """Main backlog cleanup execution."""
        # Check if jira-api script exists
        if not self.utils.jira_api.exists() or not os.access(self.utils.jira_api, os.X_OK):
            print(f"❌ Error: jira-api script not found at {self.utils.jira_api}", file=sys.stderr)
            sys.exit(1)

        # Handle list teams
        if args.list_teams:
            self.utils.list_teams(self.config_file)
            return

        # Load team configuration
        try:
            team_config = self.utils.load_team_config(args.team, self.config_file)
        except (FileNotFoundError, ValueError) as e:
            print(f"❌ Error: {e}", file=sys.stderr)
            print("Available teams:", file=sys.stderr)
            self.utils.list_teams(self.config_file)
            sys.exit(1)

        # Build backlog JQL from projects or use custom override
        projects = team_config.get('projects', '')
        display_name = team_config.get('display_name', args.team)

        if hasattr(args, 'backlog_jql') and args.backlog_jql:
            # Use custom JQL override
            backlog_jql = args.backlog_jql
        elif projects:
            # Build default JQL from projects
            backlog_jql = f'project IN ({projects}) AND sprint is EMPTY AND statusCategory != Done AND type not in (Deploy, Request)'
        else:
            # Fallback to configured JQL (for backward compatibility)
            backlog_jql = team_config.get('backlog_jql', '')
            if not backlog_jql:
                print(f"❌ Error: Team '{args.team}' missing 'projects' or 'backlog_jql' field in config", file=sys.stderr)
                sys.exit(1)

        # Modify JQL to include or exclude deferred tickets
        if hasattr(args, 'include_deferred') and args.include_deferred:
            # Remove the "status != Deferred" filter if present
            backlog_jql = backlog_jql.replace(' AND status != Deferred', '')
        else:
            # Ensure deferred tickets are excluded (add filter if not present)
            if 'status != Deferred' not in backlog_jql:
                backlog_jql += ' AND status != Deferred'

        # Calculate summary length based on terminal width
        terminal_width = self.utils.get_terminal_width()
        calculated_summary_length = self.utils.calculate_summary_length(terminal_width, args.length)

        # Determine if colors should be used
        use_colors = self.utils.determine_colors(args)

        # Display header
        print(f"{display_name} Backlog Cleanup - {datetime.now().strftime('%Y-%m-%d %H:%M')} [Width: {terminal_width}, Summary: {calculated_summary_length} chars]")
        print("=" * 50)
        print()

        # Show backlog
        self.show_backlog(backlog_jql, args.count, calculated_summary_length, use_colors)


def main():
    parser = argparse.ArgumentParser(description='Backlog cleanup tool showing prioritized backlog items for triage')

    utils = JiraUtils()
    utils.add_common_arguments(parser, include_team=True, include_count=True,
                              default_count=20, include_deferred=True, include_backlog_jql=True)

    args = parser.parse_args()

    cleanup = BacklogCleanup()
    cleanup.run(args)


if __name__ == '__main__':
    main()