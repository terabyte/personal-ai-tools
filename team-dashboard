#!/usr/bin/env bash

# Team Dashboard - Quick sprint and backlog overview
# Shows current sprint status and top backlog items for any team

SELF="$(basename "$0")"
JIRA_API="$(dirname "$0")/jira-api"
CONFIG_FILE="$(dirname "$0")/team-dashboard.conf"

function usage {
    cat <<EOF
$SELF: Team dashboard showing current sprint and backlog

USAGE:
    $SELF [OPTIONS] [TEAM]

ARGUMENTS:
    TEAM                   Team name from config file (default: ciplat)

OPTIONS:
    -t, --team TEAM        Team name (same as positional argument)
    -s, --sprint SPRINT    Specify sprint name (default: auto-detect current sprint)
    -n, --count N          Number of backlog items to show (default: 10)
    -l, --length N         Summary length in characters (default: auto-detect)
    -c, --color           Force enable colors (auto-detects by default)
    --no-color            Force disable colors
    --list-teams          Show available teams from config file
    -h, --help            Show this help

EXAMPLES:
    $SELF                                    # Show CIPLAT dashboard (default)
    $SELF cdplat                            # Show CDPLAT dashboard
    $SELF --team ciplat-support             # Show CIPLAT support dashboard
    $SELF cdplat --count 5                  # CDPLAT with top 5 backlog items
    $SELF --list-teams                      # Show available teams

EOF
}

function list_teams {
    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo "❌ Config file not found: $CONFIG_FILE"
        return 1
    fi

    echo "Available teams:"
    grep '^\[' "$CONFIG_FILE" | sed 's/\[//g; s/\]//g' | while read team; do
        display_name=$(get_config_value "$team" "display_name")
        echo "  $team - $display_name"
    done
}

function get_config_value {
    local team="$1"
    local key="$2"

    if [[ ! -f "$CONFIG_FILE" ]]; then
        echo ""
        return 1
    fi

    # Parse INI-style config file
    awk -v team="[$team]" -v key="$key" '
    BEGIN { in_section = 0 }
    /^\[.*\]$/ {
        in_section = ($0 == team) ? 1 : 0
        next
    }
    in_section && $0 ~ "^" key "[ ]*=" {
        sub("^" key "[ ]*=[ ]*", "")
        print $0
        exit
    }
    ' "$CONFIG_FILE"
}

function get_current_sprint {
    local team="$1"
    # Try to detect current sprint by looking for recently updated tickets with sprint info
    # This is a heuristic since we can't access sprint API directly
    local current_date=$(date +"%Y-%m-%d")

    # Team-specific sprint naming
    case "$team" in
        ciplat|ciplat-support)
            echo "CIPLAT $(date -d "next monday" +"%Y-%m-%d" 2>/dev/null || echo "2025-10-07")"
            ;;
        cdplat|cdplat-support)
            echo "CDPLAT $(date -d "next monday" +"%Y-%m-%d" 2>/dev/null || echo "2025-10-07")"
            ;;
        *)
            echo "$team $(date -d "next monday" +"%Y-%m-%d" 2>/dev/null || echo "2025-10-07")"
            ;;
    esac
}

function show_sprint_status {
    local sprint_name="$1"
    local summary_length="$2"
    local sprint_jql="$3"
    echo ">> CURRENT SPRINT: $sprint_name"
    echo "=" | head -c 60; echo

    # Get recent tickets and categorize by status using team JQL
    local jql="$sprint_jql"
    local response=$($JIRA_API GET "/search/jql?jql=$(printf '%s' "$jql" | sed 's/ /%20/g')&fields=key,summary,status,assignee,priority,customfield_10061,updated&maxResults=50" 2>/dev/null)

    if [[ $? -ne 0 ]] || [[ -z "$response" ]]; then
        echo "❌ Failed to fetch sprint data"
        return 1
    fi

    # Parse and categorize by status
    echo "$response" | SUMMARY_LENGTH="$summary_length" USE_COLORS="$use_colors" python3 -c "
import json, sys, os
from datetime import datetime, timezone
try:
    data = json.load(sys.stdin)
    issues = data.get('issues', [])
    use_colors = os.environ.get('USE_COLORS', 'false') == 'true'

    # Group by status category
    blocked = []
    todo = []
    in_progress = []
    in_review = []
    done = []

    for issue in issues:
        fields = issue.get('fields', {})
        key = issue.get('key', 'N/A')  # Key is at top level, not in fields
        full_summary = fields.get('summary', 'No summary')
        max_length = int(os.environ.get('SUMMARY_LENGTH', 125))
        summary = full_summary[:max_length]
        # Only add ... if we actually truncated
        summary_suffix = '...' if len(full_summary) > max_length else ''

        status_info = fields.get('status', {})
        status_name = status_info.get('name', 'Unknown')
        status_category = status_info.get('statusCategory', {}).get('key', '')
        assignee = fields.get('assignee')
        # Try to get username first, fallback to display name
        if assignee:
            assignee_email = assignee.get('emailAddress', '')
            if assignee_email and '@' in assignee_email:
                assignee_name = assignee_email.split('@')[0]  # LDAP username
            else:
                assignee_name = assignee.get('displayName', '')
        else:
            assignee_name = ''

        story_points = fields.get('customfield_10061', 0) or 0  # Story points field
        # Format story points as integer if whole number, otherwise float
        if isinstance(story_points, (int, float)) and story_points == int(story_points):
            story_points_str = str(int(story_points))
        else:
            story_points_str = str(story_points)

        # Calculate days since last update
        updated_str = fields.get('updated', '')
        if updated_str:
            try:
                # Parse ISO format: 2025-09-26T14:10:21.467-0500
                # Fix timezone format for Python compatibility
                if updated_str.count(':') == 2 and ('+' in updated_str[-5:] or '-' in updated_str[-5:]):
                    # Add colon to timezone: -0500 -> -05:00
                    updated_str = updated_str[:-2] + ':' + updated_str[-2:]
                updated_dt = datetime.fromisoformat(updated_str)
                now = datetime.now(timezone.utc)
                days_diff = (now - updated_dt).days

                # Format days with color in sprint section too
                if days_diff == 0:
                    days_text = 'today'
                elif days_diff == 1:
                    days_text = '1d'
                else:
                    days_text = f'{days_diff}d'

                # Apply color based on days and color settings
                if use_colors:
                    if days_diff < 2:
                        days_part = f'\033[32m({days_text})\033[0m'  # Green < 2 days
                    elif days_diff <= 4:
                        days_part = f'\033[33m({days_text})\033[0m'  # Yellow 2-4 days
                    else:
                        days_part = f'({days_text})'  # Standard (no color) > 4 days
                else:
                    days_part = f'({days_text})'
            except:
                days_part = '(?d)'
        else:
            days_part = '(?d)'

        # Format: CIPLAT-1234 (3d) [3pt, User] or CIPLAT-1234 (3d) [3pt] if unassigned
        assignee_part = f', {assignee_name}' if assignee_name else ''
        item = f'{key} {days_part} [{story_points_str}pt{assignee_part}]: {summary}{summary_suffix}'

        # Categorize by status
        if 'blocked' in status_name.lower():
            blocked.append(item)
        elif status_category == 'new' or 'triage' in status_name.lower():
            todo.append(item)
        elif status_category == 'indeterminate' or 'progress' in status_name.lower():
            in_progress.append(item)
        elif 'review' in status_name.lower():
            in_review.append(item)
        elif status_category == 'done':
            done.append(item)
        else:
            todo.append(item)  # Default fallback

    # Display sections
    if blocked:
        print('BLOCKED:')
        for item in blocked[:5]: print(f'   {item}')
        print()

    if todo:
        print('TO-DO:')
        for item in todo[:5]: print(f'   {item}')
        print()

    if in_progress:
        print('IN PROGRESS:')
        for item in in_progress[:5]: print(f'   {item}')
        print()

    if in_review:
        print('IN REVIEW:')
        for item in in_review[:5]: print(f'   {item}')
        print()

    if done:
        print('RECENTLY DONE:')
        for item in done[:3]: print(f'   {item}')
        print()

except Exception as e:
    print(f'Error parsing sprint data: {e}')
"
}

function show_backlog {
    local count=${1:-10}
    local summary_length=${2:-125}
    local use_colors=${3:-false}
    local backlog_jql="$4"
    echo ">> TOP BACKLOG (Next $count items)"
    echo "=" | head -c 40; echo

    if [[ "$use_colors" == "true" ]]; then
        echo -e "\033[32m[B]\033[0m on Backlog  \033[33m[T]\033[0m Pending Triage  \033[31m[X]\033[0m Blocked"
    else
        echo "[B] on Backlog  [T] Pending Triage  [X] Blocked"
    fi
    echo

    # Get backlog items using team JQL
    local jql="$backlog_jql"
    local response=$($JIRA_API GET "/search/jql?jql=$(printf '%s' "$jql" | sed 's/ /%20/g')&fields=key,summary,priority,created,assignee,customfield_10061,customfield_10022,status,updated&maxResults=100" 2>/dev/null)

    if [[ $? -ne 0 ]] || [[ -z "$response" ]]; then
        echo "❌ Failed to fetch backlog data"
        return 1
    fi

    echo "$response" | SUMMARY_LENGTH="$summary_length" USE_COLORS="$use_colors" python3 -c "
import json, sys, os
from datetime import datetime, timezone
try:
    data = json.load(sys.stdin)
    issues = data.get('issues', [])
    use_colors = os.environ.get('USE_COLORS', 'false') == 'true'

    # Sort issues by rank field (customfield_10022) to get proper backlog order
    # Jira rank format is like '0|hzzwg1:2' or '0|i003pj:00ibi06020909'
    # The part after | contains prefix:suffix - we need to sort by prefix then suffix
    def get_rank_sort_key(issue):
        fields = issue.get('fields', {})
        rank = fields.get('customfield_10022', '')
        if rank and '|' in rank and ':' in rank:
            # Extract the rank part after the pipe: 'hzzwg1:2'
            rank_part = rank.split('|')[1]
            if ':' in rank_part:
                prefix, suffix = rank_part.split(':', 1)
                # Create a sort key that sorts by prefix first, then suffix
                # Pad numeric suffixes for proper ordering
                if suffix.rstrip(':').isdigit():
                    padded_suffix = suffix.rstrip(':').zfill(10)
                else:
                    padded_suffix = suffix.rstrip(':')
                return (prefix, padded_suffix)
        # Fallback to issue key for consistent ordering
        issue_key = issue.get('key', 'ZZZZ-9999')
        issue_num = issue_key.split('-')[-1] if '-' in issue_key else '9999'
        return ('zzz_fallback', issue_num.zfill(10))

    # Sort issues by rank
    issues_sorted = sorted(issues, key=get_rank_sort_key)

    # Limit to requested count
    count = $count
    limited_issues = issues_sorted[:count]

    for i, issue in enumerate(limited_issues, 1):
        fields = issue.get('fields', {})
        key = issue.get('key', 'N/A')  # Key is at top level, not in fields
        full_summary = fields.get('summary', 'No summary')
        max_length = int(os.environ.get('SUMMARY_LENGTH', 125))
        summary = full_summary[:max_length]
        # Only add ... if we actually truncated
        summary_suffix = '...' if len(full_summary) > max_length else ''

        priority = fields.get('priority', {}).get('name', 'No Priority')
        status_name = fields.get('status', {}).get('name', 'Unknown')
        assignee = fields.get('assignee')
        # Try to get username first, fallback to display name
        if assignee:
            assignee_email = assignee.get('emailAddress', '')
            if assignee_email and '@' in assignee_email:
                assignee_name = assignee_email.split('@')[0]  # LDAP username
            else:
                assignee_name = assignee.get('displayName', '')
        else:
            assignee_name = ''

        story_points = fields.get('customfield_10061', 0) or 0  # Story points field
        # Format story points as integer if whole number, otherwise float
        if isinstance(story_points, (int, float)) and story_points == int(story_points):
            story_points_str = str(int(story_points))
        else:
            story_points_str = str(story_points)

        # Add status indicator with optional colors
        if use_colors:
            if status_name == 'on Backlog':
                status_indicator = '\033[32m[B]\033[0m'  # Green
            elif status_name == 'Pending Triage':
                status_indicator = '\033[33m[T]\033[0m'  # Yellow
            elif 'Blocked' in status_name or status_name == 'Blocked':
                status_indicator = '\033[31m[X]\033[0m'  # Red
            else:
                status_indicator = '[?]'  # Unknown status
        else:
            if status_name == 'on Backlog':
                status_indicator = '[B]'  # on Backlog
            elif status_name == 'Pending Triage':
                status_indicator = '[T]'  # Pending Triage
            elif 'Blocked' in status_name or status_name == 'Blocked':
                status_indicator = '[X]'  # Blocked
            else:
                status_indicator = '[?]'  # Unknown status

        # Calculate days since last update with colors
        updated_str = fields.get('updated', '')
        if updated_str:
            try:
                # Parse ISO format: 2025-09-26T14:10:21.467-0500
                # Fix timezone format for Python compatibility
                if updated_str.count(':') == 2 and ('+' in updated_str[-5:] or '-' in updated_str[-5:]):
                    # Add colon to timezone: -0500 -> -05:00
                    updated_str = updated_str[:-2] + ':' + updated_str[-2:]
                updated_dt = datetime.fromisoformat(updated_str)
                now = datetime.now(timezone.utc)
                days_diff = (now - updated_dt).days

                # Format days with color based on age
                if days_diff == 0:
                    days_text = 'today'
                elif days_diff == 1:
                    days_text = '1d'
                else:
                    days_text = f'{days_diff}d'

                # Apply color based on days and color settings
                if use_colors:
                    if days_diff < 2:
                        days_part = f'\033[32m({days_text})\033[0m'  # Green < 2 days
                    elif days_diff <= 4:
                        days_part = f'\033[33m({days_text})\033[0m'  # Yellow 2-4 days
                    else:
                        days_part = f'({days_text})'  # Standard (no color) > 4 days
                else:
                    days_part = f'({days_text})'
            except:
                days_part = '(?d)'
        else:
            days_part = '(?d)'

        # Format: CIPLAT-1234 _3d_ [3pt, User] or CIPLAT-1234 _3d_ [3pt] if unassigned
        assignee_part = f', {assignee_name}' if assignee_name else ''
        print(f'{i:2d}. {status_indicator} {key} {days_part} [{story_points_str}pt{assignee_part}]: {summary}{summary_suffix} [{priority}]')

    if not limited_issues:
        print('   No backlog items found in triage status')
    elif len(issues_sorted) > count:
        print(f'   ... and {len(issues_sorted) - count} more items in backlog')

except Exception as e:
    print(f'Error parsing backlog data: {e}')
"
}

function get_terminal_width {
    # Try to get terminal width, fallback to a generous default for modern terminals
    local width=$(tput cols 2>/dev/null || echo "120")
    echo "$width"
}

function supports_colors {
    # Check if terminal supports colors - be more permissive for xterm
    [[ "${TERM}" == *"xterm"* ]] || [[ "${TERM}" == *"color"* ]] || [[ "${TERM}" == "screen"* ]]
}

function calculate_summary_length {
    local terminal_width="$1"
    local base_length=125  # Default length

    # If length was specified via -l, use that
    if [[ -n "$2" ]]; then
        echo "$2"
        return
    fi

    # Calculate dynamic length based on terminal width
    # Reserve space for: "NN. [X] CIPLAT-NNNN [NNpt, username]: ... [Priority]"
    # That's roughly 50-60 chars, so summary gets the rest
    local reserved_space=60
    local available_space=$((terminal_width - reserved_space))

    # Use at least 80 chars (2.5x the original 50), at most 250 chars
    if [[ $available_space -lt 80 ]]; then
        echo "80"  # Generous minimum for modern terminals
    elif [[ $available_space -gt 250 ]]; then
        echo "250"
    else
        echo "$available_space"
    fi
}

function main {
    local sprint_name=""
    local backlog_count=10
    local summary_length=""
    local force_colors=""
    local team="ciplat"  # default team

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -t|--team)
                team="$2"
                shift 2
                ;;
            -s|--sprint)
                sprint_name="$2"
                shift 2
                ;;
            -n|--count)
                backlog_count="$2"
                shift 2
                ;;
            -l|--length)
                summary_length="$2"
                shift 2
                ;;
            -c|--color)
                force_colors="true"
                shift
                ;;
            --no-color)
                force_colors="false"
                shift
                ;;
            --list-teams)
                list_teams
                exit 0
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            -*)
                echo "Unknown option: $1" >&2
                usage
                exit 1
                ;;
            *)
                # Positional argument - team name
                team="$1"
                shift
                ;;
        esac
    done

    # Check if jira-api script exists
    if [[ ! -x "$JIRA_API" ]]; then
        echo "❌ Error: jira-api script not found at $JIRA_API" >&2
        exit 1
    fi

    # Load team configuration
    local sprint_jql=$(get_config_value "$team" "sprint_jql")
    local backlog_jql=$(get_config_value "$team" "backlog_jql")
    local display_name=$(get_config_value "$team" "display_name")

    if [[ -z "$sprint_jql" ]] || [[ -z "$backlog_jql" ]]; then
        echo "❌ Error: Team '$team' not found in config file $CONFIG_FILE" >&2
        echo "Available teams:" >&2
        list_teams >&2
        exit 1
    fi

    # Get current sprint name if not provided
    if [[ -z "$sprint_name" ]]; then
        sprint_name=$(get_current_sprint "$team")
    fi

    # Calculate summary length based on terminal width
    local terminal_width=$(get_terminal_width)
    local calculated_summary_length=$(calculate_summary_length "$terminal_width" "$summary_length")

    # Determine if colors should be used
    local use_colors=false
    if [[ "$force_colors" == "true" ]]; then
        use_colors=true
    elif [[ "$force_colors" == "false" ]]; then
        use_colors=false
    elif supports_colors; then
        use_colors=true
    fi

    echo "$display_name Dashboard - $(date '+%Y-%m-%d %H:%M') [Width: $terminal_width, Summary: $calculated_summary_length chars]"
    echo "=" | head -c 50; echo
    echo

    # Show sprint status
    show_sprint_status "$sprint_name" "$calculated_summary_length" "$sprint_jql"
    echo

    # Show backlog
    show_backlog "$backlog_count" "$calculated_summary_length" "$use_colors" "$backlog_jql"
}

main "$@"