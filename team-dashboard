#!/usr/bin/env python3

"""
Team Dashboard - Quick sprint and backlog overview
Shows current sprint status and top backlog items for any team
"""

import argparse
import configparser
import json
import os
import re
import shutil
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional, Tuple


class TeamDashboard:
    def __init__(self):
        self.script_dir = Path(__file__).parent
        self.jira_api = self.script_dir / "jira-api"
        self.config_file = self.script_dir / "team-dashboard.conf"

    def get_terminal_width(self) -> int:
        """Get terminal width, fallback to generous default for modern terminals."""
        try:
            return shutil.get_terminal_size().columns
        except:
            return 120

    def supports_colors(self) -> bool:
        """Check if terminal supports colors - be more permissive for xterm."""
        term = os.environ.get('TERM', '')
        return any(term_type in term for term_type in ['xterm', 'color', 'screen'])

    def calculate_summary_length(self, terminal_width: int, override_length: Optional[int] = None) -> int:
        """Calculate optimal summary length based on terminal width."""
        if override_length:
            return override_length

        # Reserve space for: "NN. [X] CIPLAT-NNNN (Nd) [NNpt, username]: ... [Priority]"
        # That's roughly 50-60 chars, so summary gets the rest
        reserved_space = 60
        available_space = terminal_width - reserved_space

        # Use at least 80 chars (2.5x the original 50), at most 250 chars
        if available_space < 80:
            return 80  # Generous minimum for modern terminals
        elif available_space > 250:
            return 250
        else:
            return available_space

    def load_team_config(self, team: str) -> Dict[str, str]:
        """Load team configuration from config file."""
        if not self.config_file.exists():
            raise FileNotFoundError(f"Config file not found: {self.config_file}")

        config = configparser.ConfigParser()
        config.read(self.config_file)

        if team not in config:
            available_teams = list(config.sections())
            raise ValueError(f"Team '{team}' not found. Available teams: {available_teams}")

        team_config = dict(config[team])
        required_fields = ['display_name', 'sprint_jql', 'backlog_jql']

        for field in required_fields:
            if field not in team_config:
                raise ValueError(f"Missing required field '{field}' for team '{team}'")

        return team_config

    def list_teams(self) -> None:
        """List all available teams from config file."""
        if not self.config_file.exists():
            print(f"❌ Config file not found: {self.config_file}")
            return

        config = configparser.ConfigParser()
        config.read(self.config_file)

        print("Available teams:")
        for team in config.sections():
            display_name = config.get(team, 'display_name', fallback=team)
            print(f"  {team} - {display_name}")

    def call_jira_api(self, endpoint: str) -> Optional[dict]:
        """Call jira-api script and return parsed JSON response."""
        try:
            cmd = [str(self.jira_api), "GET", endpoint]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

            if result.returncode != 0:
                print(f"❌ Jira API call failed: {result.stderr}", file=sys.stderr)
                return None

            return json.loads(result.stdout)
        except (subprocess.TimeoutExpired, json.JSONDecodeError, Exception) as e:
            print(f"❌ Error calling Jira API: {e}", file=sys.stderr)
            return None

    def extract_sprint_name_from_jql(self, jql: str) -> Optional[str]:
        """Extract sprint name from JQL query."""
        match = re.search(r'sprint\s*=\s*"([^"]+)"', jql)
        return match.group(1) if match else None

    def calculate_days_since_update(self, updated_str: str) -> Tuple[int, str]:
        """Calculate days since last update and return (days, formatted_string)."""
        try:
            # Parse ISO format: 2025-09-26T14:10:21.467-0500
            # Fix timezone format for Python compatibility
            if updated_str.count(':') == 2 and ('+' in updated_str[-5:] or '-' in updated_str[-5:]):
                # Add colon to timezone: -0500 -> -05:00
                updated_str = updated_str[:-2] + ':' + updated_str[-2:]

            updated_dt = datetime.fromisoformat(updated_str)
            now = datetime.now(timezone.utc)
            days_diff = (now - updated_dt.astimezone(timezone.utc)).days

            if days_diff == 0:
                return days_diff, 'today'
            elif days_diff == 1:
                return days_diff, '1d'
            else:
                return days_diff, f'{days_diff}d'
        except Exception:
            return -1, '?d'

    def format_days_with_color(self, days: int, days_text: str, use_colors: bool) -> str:
        """Format days with appropriate color coding."""
        if use_colors:
            if days < 2:
                return f'\033[32m({days_text})\033[0m'  # Green < 2 days
            elif days <= 4:
                return f'\033[33m({days_text})\033[0m'  # Yellow 2-4 days
            else:
                return f'({days_text})'  # Standard (no color) > 4 days
        else:
            return f'({days_text})'

    def format_status_indicator(self, status_name: str, use_colors: bool) -> str:
        """Format status indicator with appropriate colors."""
        # Map status to single letter indicators
        status_map = {
            'Pending Triage': 'T',
            'on Backlog': 'B',
            'To Do': 'T',
            'In Progress': 'P',
            'In Review': 'R',
            'Pending Review': 'R',
            'Done': 'D',
            'Closed': 'D',
            'Blocked': 'X'
        }

        letter = status_map.get(status_name, '?')

        if use_colors:
            if letter == 'D':
                return f'\033[32m[{letter}]\033[0m'  # Green for done
            elif letter in ['P', 'R']:
                return f'\033[33m[{letter}]\033[0m'  # Yellow for active
            elif letter == 'X':
                return f'\033[31m[{letter}]\033[0m'  # Red for blocked
            elif letter == 'T':
                return f'\033[33m[{letter}]\033[0m'  # Yellow for triage
            elif letter == 'B':
                return f'\033[32m[{letter}]\033[0m'  # Green for backlog
            else:
                return f'[{letter}]'  # Standard for unknown
        else:
            return f'[{letter}]'

    def format_story_points(self, points) -> str:
        """Format story points as integer if whole number, otherwise float."""
        if points is None:
            return "0"
        try:
            if float(points) == int(float(points)):
                return str(int(float(points)))
            else:
                return str(points)
        except (ValueError, TypeError):
            return "0"

    def get_assignee_name(self, assignee_data) -> str:
        """Extract username from assignee data, preferring email username."""
        if not assignee_data:
            return ""

        email = assignee_data.get('emailAddress', '')
        if email and '@' in email:
            return email.split('@')[0]  # LDAP username
        else:
            return assignee_data.get('displayName', '')

    def is_ticket_added_after_sprint_start(self, issue: dict) -> bool:
        """Check if ticket was added to sprint after it started (at least 1 day after)."""
        try:
            fields = issue.get('fields', {})
            created_str = fields.get('created', '')
            sprints = fields.get('customfield_10021', [])

            if not created_str or not sprints:
                return False

            # Parse ticket creation date
            if created_str.count(':') == 2 and ('+' in created_str[-5:] or '-' in created_str[-5:]):
                created_str = created_str[:-2] + ':' + created_str[-2:]
            created_dt = datetime.fromisoformat(created_str)

            # Find the active sprint start date
            for sprint in sprints:
                if sprint.get('state') == 'active':
                    start_date_str = sprint.get('startDate', '')
                    if start_date_str:
                        # Parse sprint start date
                        if start_date_str.count(':') == 2 and ('+' in start_date_str[-5:] or '-' in start_date_str[-5:]):
                            start_date_str = start_date_str[:-2] + ':' + start_date_str[-2:]
                        elif start_date_str.endswith('Z'):
                            start_date_str = start_date_str[:-1] + '+00:00'

                        start_dt = datetime.fromisoformat(start_date_str)

                        # Check if created at least 1 day after sprint start
                        time_diff = created_dt.astimezone(timezone.utc) - start_dt.astimezone(timezone.utc)
                        return time_diff.days >= 1

            return False
        except Exception:
            return False

    def categorize_tickets_by_status(self, issues: List[dict], summary_length: int, use_colors: bool) -> Dict[str, List[str]]:
        """Categorize tickets by status and format them."""
        categories = {
            'blocked': [],
            'todo': [],
            'in_progress': [],
            'in_review': [],
            'done': []
        }

        for issue in issues:
            fields = issue.get('fields', {})
            key = issue.get('key', 'N/A')

            # Get basic fields
            full_summary = fields.get('summary', 'No summary')
            summary = full_summary[:summary_length]
            summary_suffix = '...' if len(full_summary) > summary_length else ''

            status_info = fields.get('status', {})
            status_name = status_info.get('name', 'Unknown')
            status_category = status_info.get('statusCategory', {}).get('key', '')

            assignee = fields.get('assignee')
            assignee_name = self.get_assignee_name(assignee)

            story_points = self.format_story_points(fields.get('customfield_10061'))

            # Calculate days since update
            updated_str = fields.get('updated', '')
            days, days_text = self.calculate_days_since_update(updated_str)
            days_part = self.format_days_with_color(days, days_text, use_colors)

            # Check if ticket was added after sprint start
            added_after_start = self.is_ticket_added_after_sprint_start(issue)
            if added_after_start:
                asterisk = '\033[31m*\033[0m' if use_colors else '*'
            else:
                asterisk = ' '  # Space to maintain alignment

            # Format ticket line with priority and optional due date
            assignee_part = f', {assignee_name}' if assignee_name else ''
            priority_info = fields.get('priority', {})
            priority_name = priority_info.get('name', 'No Priority')
            priority_part = f'[P:{priority_name}]'

            # Check for due date
            due_date_field = fields.get('duedate', '')
            due_part = f'[DUE:{due_date_field}] ' if due_date_field else ''

            item = f'{asterisk} {key} {days_part} [{story_points}pt{assignee_part}] {due_part}{priority_part}: {summary}{summary_suffix}'

            # Categorize by status
            if 'blocked' in status_name.lower():
                categories['blocked'].append(item)
            elif status_category == 'new' or 'triage' in status_name.lower():
                categories['todo'].append(item)
            elif status_category == 'indeterminate' or 'progress' in status_name.lower():
                categories['in_progress'].append(item)
            elif 'review' in status_name.lower():
                categories['in_review'].append(item)
            elif status_category == 'done':
                categories['done'].append(item)
            else:
                categories['todo'].append(item)  # Default fallback

        return categories

    def show_sprint_status(self, sprint_jql: str, summary_length: int, use_colors: bool) -> None:
        """Show current sprint status with tickets categorized by workflow stage."""
        # Extract sprint name from JQL
        sprint_name = self.extract_sprint_name_from_jql(sprint_jql)
        if sprint_name:
            print(f">> CURRENT SPRINT: {sprint_name}")
        else:
            print(">> CURRENT SPRINT: (from JQL query)")

        print("=" * 60)
        print()

        # Query Jira for sprint tickets (include created date, sprint info, and due date)
        jql_encoded = sprint_jql.replace(' ', '%20')
        endpoint = f"/search/jql?jql={jql_encoded}&fields=key,summary,status,assignee,priority,customfield_10061,updated,created,customfield_10021,duedate&maxResults=50"

        response = self.call_jira_api(endpoint)
        if not response:
            print("❌ Failed to fetch sprint data")
            return

        issues = response.get('issues', [])
        categories = self.categorize_tickets_by_status(issues, summary_length, use_colors)

        # Display sections
        for section_name, section_key in [
            ('BLOCKED:', 'blocked'),
            ('TO-DO:', 'todo'),
            ('IN PROGRESS:', 'in_progress'),
            ('IN REVIEW:', 'in_review'),
            ('RECENTLY DONE:', 'done')
        ]:
            items = categories[section_key]
            if items:
                print(section_name)
                limit = 3 if section_key == 'done' else 5
                for item in items[:limit]:
                    print(f'   {item}')
                print()

    def sort_backlog_by_rank(self, issues: List[dict]) -> List[dict]:
        """Sort issues by Jira rank field (customfield_10022)."""
        def get_rank_sort_key(issue):
            fields = issue.get('fields', {})
            rank = fields.get('customfield_10022', '')

            if rank and '|' in rank and ':' in rank:
                # Extract rank part after pipe: 'hzzwg1:2'
                rank_part = rank.split('|')[1]
                if ':' in rank_part:
                    prefix, suffix = rank_part.split(':', 1)
                    # Create sort key that sorts by prefix first, then suffix
                    # Pad numeric suffixes for proper ordering
                    suffix_clean = suffix.rstrip(':')
                    if suffix_clean.isdigit():
                        padded_suffix = suffix_clean.zfill(10)
                    else:
                        padded_suffix = suffix_clean
                    return (prefix, padded_suffix)

            # Fallback to issue key for consistent ordering
            issue_key = issue.get('key', 'ZZZZ-9999')
            issue_num = issue_key.split('-')[-1] if '-' in issue_key else '9999'
            return ('zzz_fallback', issue_num.zfill(10))

        return sorted(issues, key=get_rank_sort_key)

    def show_backlog(self, backlog_jql: str, count: int, summary_length: int, use_colors: bool) -> None:
        """Show top backlog items with status indicators."""
        print(f">> TOP BACKLOG (Next {count} items)")
        print("=" * 40)

        if use_colors:
            print("\033[32m[B]\033[0m Backlog  \033[33m[T]\033[0m Triage  \033[33m[P]\033[0m In Progress  \033[33m[R]\033[0m In Review  \033[31m[X]\033[0m Blocked")
        else:
            print("[B] Backlog  [T] Triage  [P] In Progress  [R] In Review  [X] Blocked")
        print()

        # Query Jira for backlog tickets (include due date)
        jql_encoded = backlog_jql.replace(' ', '%20')
        endpoint = f"/search/jql?jql={jql_encoded}&fields=key,summary,priority,created,assignee,customfield_10061,customfield_10022,status,updated,duedate&maxResults=100"

        response = self.call_jira_api(endpoint)
        if not response:
            print("❌ Failed to fetch backlog data")
            return

        issues = response.get('issues', [])
        if not issues:
            print("   No backlog items found")
            return

        # Sort by rank and limit to requested count
        issues_sorted = self.sort_backlog_by_rank(issues)
        limited_issues = issues_sorted[:count]

        for i, issue in enumerate(limited_issues, 1):
            fields = issue.get('fields', {})
            key = issue.get('key', 'N/A')

            # Get basic fields
            full_summary = fields.get('summary', 'No summary')
            summary = full_summary[:summary_length]
            summary_suffix = '...' if len(full_summary) > summary_length else ''

            priority = fields.get('priority', {}).get('name', 'No Priority')
            status_name = fields.get('status', {}).get('name', 'Unknown')
            assignee = fields.get('assignee')
            assignee_name = self.get_assignee_name(assignee)

            story_points = self.format_story_points(fields.get('customfield_10061'))

            # Calculate days since update with colors
            updated_str = fields.get('updated', '')
            days, days_text = self.calculate_days_since_update(updated_str)
            days_part = self.format_days_with_color(days, days_text, use_colors)

            # Status indicator
            status_indicator = self.format_status_indicator(status_name, use_colors)

            # Format final line with priority and optional due date
            assignee_part = f', {assignee_name}' if assignee_name else ''
            priority_part = f'[P:{priority}]'

            # Check for due date
            due_date_field = fields.get('duedate', '')
            due_part = f'[DUE:{due_date_field}] ' if due_date_field else ''

            print(f'{i:2d}. {status_indicator} {key} {days_part} [{story_points}pt{assignee_part}] {due_part}{priority_part}: {summary}{summary_suffix}')

        if len(issues_sorted) > count:
            print(f'   ... and {len(issues_sorted) - count} more items in backlog')

    def run(self, args) -> None:
        """Main dashboard execution."""
        # Check if jira-api script exists
        if not self.jira_api.exists() or not os.access(self.jira_api, os.X_OK):
            print(f"❌ Error: jira-api script not found at {self.jira_api}", file=sys.stderr)
            sys.exit(1)

        # Handle list teams
        if args.list_teams:
            self.list_teams()
            return

        # Load team configuration
        try:
            team_config = self.load_team_config(args.team)
        except (FileNotFoundError, ValueError) as e:
            print(f"❌ Error: {e}", file=sys.stderr)
            if hasattr(self, 'list_teams'):
                print("Available teams:", file=sys.stderr)
                self.list_teams()
            sys.exit(1)

        sprint_jql = team_config['sprint_jql']
        backlog_jql = team_config['backlog_jql']
        display_name = team_config['display_name']

        # Calculate summary length based on terminal width
        terminal_width = self.get_terminal_width()
        calculated_summary_length = self.calculate_summary_length(terminal_width, args.length)

        # Determine if colors should be used
        use_colors = False
        if args.color:
            use_colors = True
        elif args.no_color:
            use_colors = False
        elif self.supports_colors():
            use_colors = True

        # Display header
        print(f"{display_name} Dashboard - {datetime.now().strftime('%Y-%m-%d %H:%M')} [Width: {terminal_width}, Summary: {calculated_summary_length} chars]")
        print("=" * 50)
        print()

        # Show sprint status
        self.show_sprint_status(sprint_jql, calculated_summary_length, use_colors)
        print()

        # Show backlog
        self.show_backlog(backlog_jql, args.count, calculated_summary_length, use_colors)


def main():
    parser = argparse.ArgumentParser(description='Team dashboard showing current sprint and backlog')
    parser.add_argument('team', nargs='?', default='ciplat', help='Team name from config file (default: ciplat)')
    parser.add_argument('-t', '--team-name', dest='team', help='Team name (same as positional argument)')
    parser.add_argument('-s', '--sprint', help='Specify sprint name (default: auto-detect current sprint)')
    parser.add_argument('-n', '--count', type=int, default=10, help='Number of backlog items to show (default: 10)')
    parser.add_argument('-l', '--length', type=int, help='Summary length in characters (default: auto-detect)')
    parser.add_argument('-c', '--color', action='store_true', help='Force enable colors (auto-detects by default)')
    parser.add_argument('--no-color', action='store_true', help='Force disable colors')
    parser.add_argument('--list-teams', action='store_true', help='Show available teams from config file')

    args = parser.parse_args()

    dashboard = TeamDashboard()
    dashboard.run(args)


if __name__ == '__main__':
    main()