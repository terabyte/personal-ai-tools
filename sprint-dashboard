#!/usr/bin/env python3

"""
Team Dashboard - Quick sprint and backlog overview
Shows current sprint status and top backlog items for any team
"""

import argparse
import configparser
import json
import os
import re
import shutil
import subprocess
import sys
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List, Optional, Tuple

from jira_utils import JiraUtils


class TeamDashboard:
    def __init__(self):
        self.script_dir = Path(__file__).parent
        self.config_file = self.script_dir / "teams.conf"
        self.utils = JiraUtils(self.script_dir)

    def get_terminal_width(self) -> int:
        """Get terminal width, fallback to generous default for modern terminals."""
        try:
            return shutil.get_terminal_size().columns
        except:
            return 120

    def supports_colors(self) -> bool:
        """Check if terminal supports colors - be more permissive for xterm."""
        term = os.environ.get('TERM', '')
        return any(term_type in term for term_type in ['xterm', 'color', 'screen'])

    def calculate_summary_length(self, terminal_width: int, override_length: Optional[int] = None) -> int:
        """Calculate optimal summary length based on terminal width."""
        if override_length:
            return override_length

        # Reserve space for: "NN. [X] CIPLAT-NNNN (Nd) [NNpt, username]: ... [Priority]"
        # That's roughly 50-60 chars, so summary gets the rest
        reserved_space = 60
        available_space = terminal_width - reserved_space

        # Use at least 80 chars (2.5x the original 50), at most 250 chars
        if available_space < 80:
            return 80  # Generous minimum for modern terminals
        elif available_space > 250:
            return 250
        else:
            return available_space

    def load_team_config(self, team: str) -> Dict[str, str]:
        """Load team configuration from config file."""
        if not self.config_file.exists():
            raise FileNotFoundError(f"Config file not found: {self.config_file}")

        config = configparser.ConfigParser()
        config.read(self.config_file)

        if team not in config:
            available_teams = list(config.sections())
            raise ValueError(f"Team '{team}' not found. Available teams: {available_teams}")

        team_config = dict(config[team])
        required_fields = ['display_name', 'sprint_jql', 'backlog_jql']

        for field in required_fields:
            if field not in team_config:
                raise ValueError(f"Missing required field '{field}' for team '{team}'")

        return team_config

    def list_teams(self) -> None:
        """List all available teams from config file."""
        if not self.config_file.exists():
            print(f"❌ Config file not found: {self.config_file}")
            return

        config = configparser.ConfigParser()
        config.read(self.config_file)

        print("Available teams:")
        for team in config.sections():
            display_name = config.get(team, 'display_name', fallback=team)
            print(f"  {team} - {display_name}")

    def call_jira_api(self, endpoint: str) -> Optional[dict]:
        """Call jira-api script and return parsed JSON response."""
        try:
            cmd = [str(self.jira_api), "GET", endpoint]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)

            if result.returncode != 0:
                print(f"❌ Jira API call failed: {result.stderr}", file=sys.stderr)
                return None

            return json.loads(result.stdout)
        except (subprocess.TimeoutExpired, json.JSONDecodeError, Exception) as e:
            print(f"❌ Error calling Jira API: {e}", file=sys.stderr)
            return None

    def extract_sprint_name_from_jql(self, jql: str) -> Optional[str]:
        """Extract sprint name from JQL query."""
        match = re.search(r'sprint\s*=\s*"([^"]+)"', jql)
        return match.group(1) if match else None

    def calculate_days_since_update(self, updated_str: str) -> Tuple[int, str]:
        """Calculate days since last update and return (days, formatted_string)."""
        try:
            # Parse ISO format: 2025-09-26T14:10:21.467-0500
            # Fix timezone format for Python compatibility
            if updated_str.count(':') == 2 and ('+' in updated_str[-5:] or '-' in updated_str[-5:]):
                # Add colon to timezone: -0500 -> -05:00
                updated_str = updated_str[:-2] + ':' + updated_str[-2:]

            updated_dt = datetime.fromisoformat(updated_str)
            now = datetime.now(timezone.utc)
            days_diff = (now - updated_dt.astimezone(timezone.utc)).days

            if days_diff == 0:
                return days_diff, 'today'
            elif days_diff == 1:
                return days_diff, '1d'
            else:
                return days_diff, f'{days_diff}d'
        except Exception:
            return -1, '?d'

    def format_days_with_color(self, days: int, days_text: str, use_colors: bool) -> str:
        """Format days with appropriate color coding."""
        if use_colors:
            if days < 2:
                return f'\033[32m({days_text})\033[0m'  # Green < 2 days
            elif days <= 4:
                return f'\033[33m({days_text})\033[0m'  # Yellow 2-4 days
            else:
                return f'({days_text})'  # Standard (no color) > 4 days
        else:
            return f'({days_text})'

    def format_sprint_dates(self, start_date_str: Optional[str], end_date_str: Optional[str], use_colors: bool) -> str:
        """Format sprint start and end dates with relative time and color coding."""
        try:
            now = datetime.now(timezone.utc)
            parts = []

            # Parse and format start date
            if start_date_str:
                start_dt = self.parse_jira_date(start_date_str)
                if start_dt:
                    days_since_start = (now - start_dt).days
                    if days_since_start < 0:
                        # Sprint hasn't started yet
                        days_until_start = abs(days_since_start)
                        start_text = f"starts in {days_until_start}d" if days_until_start > 0 else "starts today"
                        if use_colors:
                            start_text = f'\033[33m{start_text}\033[0m'  # Yellow for future
                    elif days_since_start == 0:
                        start_text = "started today"
                        if use_colors:
                            start_text = f'\033[32m{start_text}\033[0m'  # Green for today
                    else:
                        start_text = f"{days_since_start}d ago"
                        if use_colors and days_since_start < 3:
                            start_text = f'\033[32m{start_text}\033[0m'  # Green for recent
                    parts.append(f"Start Date: {start_dt.strftime('%Y-%m-%d')} ({start_text})")

            # Parse and format end date
            if end_date_str:
                end_dt = self.parse_jira_date(end_date_str)
                if end_dt:
                    days_until_end = (end_dt - now).days
                    if days_until_end < 0:
                        # Sprint has ended
                        days_since_end = abs(days_until_end)
                        end_text = f"ended {days_since_end}d ago"
                        if use_colors:
                            end_text = f'\033[31m{end_text}\033[0m'  # Red for ended
                    elif days_until_end == 0:
                        end_text = "ends today"
                        if use_colors:
                            end_text = f'\033[31m{end_text}\033[0m'  # Red for urgency
                    else:
                        end_text = f"{days_until_end}d from now"
                        if use_colors:
                            if days_until_end <= 2:
                                end_text = f'\033[31m{end_text}\033[0m'  # Red if < 3 days
                            elif days_until_end <= 5:
                                end_text = f'\033[33m{end_text}\033[0m'  # Yellow if 3-5 days
                            else:
                                end_text = f'\033[32m{end_text}\033[0m'  # Green if > 5 days
                    parts.append(f"End Date: {end_dt.strftime('%Y-%m-%d')} ({end_text})")

            return "   " + "  ".join(parts) if parts else ""
        except Exception:
            return ""

    def parse_jira_date(self, date_str: str) -> Optional[datetime]:
        """Parse a Jira date string into a datetime object."""
        try:
            # Handle timezone format variations
            if date_str.count(':') == 2 and ('+' in date_str[-5:] or '-' in date_str[-5:]):
                # Add colon to timezone: -0500 -> -05:00
                date_str = date_str[:-2] + ':' + date_str[-2:]
            elif date_str.endswith('Z'):
                date_str = date_str[:-1] + '+00:00'

            return datetime.fromisoformat(date_str).astimezone(timezone.utc)
        except Exception:
            return None

    def format_status_indicator(self, status_name: str, use_colors: bool) -> str:
        """Format status indicator with appropriate colors."""
        # Map status to single letter indicators
        status_map = {
            'Pending Triage': 'T',
            'on Backlog': 'B',
            'To Do': 'T',
            'In Progress': 'P',
            'In Review': 'R',
            'Pending Review': 'R',
            'Pending Requirements': 'Q',
            'Done': 'C',  # Use C for Closed/Done to free up D
            'Closed': 'C',
            'Deferred': 'D',  # Use D for Deferred (red)
            'Blocked': 'X'
        }

        letter = status_map.get(status_name, '?')

        if use_colors:
            if letter == 'C':
                return f'\033[32m[{letter}]\033[0m'  # Green for closed/done
            elif letter in ['P', 'R', 'Q']:
                return f'\033[33m[{letter}]\033[0m'  # Yellow for active/pending
            elif letter in ['D', 'X']:
                return f'\033[31m[{letter}]\033[0m'  # Red for deferred/blocked
            elif letter == 'T':
                return f'\033[33m[{letter}]\033[0m'  # Yellow for triage
            elif letter == 'B':
                return f'\033[32m[{letter}]\033[0m'  # Green for backlog
            else:
                return f'[{letter}]'  # Standard for unknown
        else:
            return f'[{letter}]'

    def format_story_points(self, points) -> str:
        """Format story points as integer if whole number, otherwise float."""
        if points is None:
            return "0"
        try:
            if float(points) == int(float(points)):
                return str(int(float(points)))
            else:
                return str(points)
        except (ValueError, TypeError):
            return "0"

    def get_assignee_name(self, assignee_data) -> str:
        """Extract username from assignee data, preferring email username."""
        if not assignee_data:
            return ""

        email = assignee_data.get('emailAddress', '')
        if email and '@' in email:
            return email.split('@')[0]  # LDAP username
        else:
            return assignee_data.get('displayName', '')

    def is_ticket_added_after_sprint_start(self, issue: dict, sprint_name: str = None) -> bool:
        """Check if ticket was added to sprint after it started (at least 1 day after)."""
        try:
            fields = issue.get('fields', {})
            created_str = fields.get('created', '')
            sprints = fields.get('customfield_10021', [])

            if not created_str or not sprints:
                return False

            # Parse ticket creation date
            if created_str.count(':') == 2 and ('+' in created_str[-5:] or '-' in created_str[-5:]):
                created_str = created_str[:-2] + ':' + created_str[-2:]
            created_dt = datetime.fromisoformat(created_str)

            # Find the specified sprint or active sprint start date
            for sprint in sprints:
                # Match by sprint name if provided, otherwise use active sprint
                sprint_matches = (sprint_name and sprint.get('name') == sprint_name) or \
                                (not sprint_name and sprint.get('state') == 'active')

                if sprint_matches:
                    start_date_str = sprint.get('startDate', '')
                    if start_date_str:
                        # Parse sprint start date
                        if start_date_str.count(':') == 2 and ('+' in start_date_str[-5:] or '-' in start_date_str[-5:]):
                            start_date_str = start_date_str[:-2] + ':' + start_date_str[-2:]
                        elif start_date_str.endswith('Z'):
                            start_date_str = start_date_str[:-1] + '+00:00'

                        start_dt = datetime.fromisoformat(start_date_str)

                        # Check if created at least 1 day after sprint start
                        time_diff = created_dt.astimezone(timezone.utc) - start_dt.astimezone(timezone.utc)
                        return time_diff.days >= 1

            return False
        except Exception:
            return False

    def categorize_tickets_by_status(self, issues: List[dict], summary_length: int, use_colors: bool) -> Dict[str, List[str]]:
        """Categorize tickets by status and format them."""
        categories = {
            'blocked': [],
            'todo': [],
            'in_progress': [],
            'in_review': [],
            'done': []
        }

        for issue in issues:
            fields = issue.get('fields', {})
            key = issue.get('key', 'N/A')

            # Get basic fields
            full_summary = fields.get('summary', 'No summary')
            summary = full_summary[:summary_length]
            summary_suffix = '...' if len(full_summary) > summary_length else ''

            status_info = fields.get('status', {})
            status_name = status_info.get('name', 'Unknown')
            status_category = status_info.get('statusCategory', {}).get('key', '')

            assignee = fields.get('assignee')
            assignee_name = self.get_assignee_name(assignee)

            story_points = self.format_story_points(fields.get('customfield_10061'))

            # Calculate days since update
            updated_str = fields.get('updated', '')
            days, days_text = self.calculate_days_since_update(updated_str)
            days_part = self.format_days_with_color(days, days_text, use_colors)

            # Check if ticket was added after sprint start
            added_after_start = self.is_ticket_added_after_sprint_start(issue)
            if added_after_start:
                asterisk = '\033[31m*\033[0m' if use_colors else '*'
            else:
                asterisk = ' '  # Space to maintain alignment

            # Format ticket line with priority and optional due date
            assignee_part = f', {assignee_name}' if assignee_name else ''
            priority_info = fields.get('priority', {})
            priority_name = priority_info.get('name', 'No Priority')
            priority_part = f'[P:{priority_name}]'

            # Check for due date
            due_date_field = fields.get('duedate', '')
            due_part = f'[DUE:{due_date_field}] ' if due_date_field else ''

            item = f'{asterisk} {key} {days_part} [{story_points}pt{assignee_part}] {due_part}{priority_part}: {summary}{summary_suffix}'

            # Categorize by status
            if 'blocked' in status_name.lower():
                categories['blocked'].append(item)
            elif status_category == 'new' or 'triage' in status_name.lower():
                categories['todo'].append(item)
            elif status_category == 'indeterminate' or 'progress' in status_name.lower():
                categories['in_progress'].append(item)
            elif 'review' in status_name.lower():
                categories['in_review'].append(item)
            elif status_category == 'done':
                categories['done'].append(item)
            else:
                categories['todo'].append(item)  # Default fallback

        return categories

    def show_sprint_status(self, sprint_jql: str, summary_length: int, use_colors: bool) -> None:
        """Show current sprint status with tickets categorized by workflow stage."""
        # Extract sprint name from JQL
        sprint_name = self.extract_sprint_name_from_jql(sprint_jql)
        if sprint_name:
            sprint_header = f">> CURRENT SPRINT: {sprint_name}"
        else:
            sprint_header = ">> CURRENT SPRINT: (from JQL query)"

        print("=" * 60)
        print()

        # Fetch all sprint tickets with proper pagination
        fields = ['key', 'summary', 'status', 'assignee', 'priority', 'customfield_10061',
                 'updated', 'created', 'customfield_10021', 'duedate']
        issues = self.utils.fetch_all_jql_results(sprint_jql, fields, max_items=200)

        # Determine sprint state and dates from issues
        sprint_state = None
        sprint_start_date = None
        sprint_end_date = None
        if issues and sprint_name:
            for issue in issues:
                fields_data = issue.get('fields', {})
                sprints = fields_data.get('customfield_10021', [])
                for sprint in sprints:
                    if sprint.get('name') == sprint_name:
                        raw_state = sprint.get('state', '')
                        # Map states to display names
                        if raw_state == 'active':
                            sprint_state = 'in-progress'
                        elif raw_state == 'future':
                            sprint_state = 'future'
                        elif raw_state == 'closed':
                            sprint_state = 'closed'

                        # Extract start and end dates
                        sprint_start_date = sprint.get('startDate')
                        sprint_end_date = sprint.get('endDate')
                        break
                if sprint_state:
                    break

        if not issues:
            state_suffix = f" [{sprint_state}]" if sprint_state else ""
            print(f"{sprint_header}{state_suffix} (0 tickets, 0 pts)")
            print("=" * 60)
            print("No tickets found in sprint")
            return

        # Categorize tickets with sprint-specific grouping
        from collections import defaultdict
        categories = defaultdict(list)
        status_counts = defaultdict(int)
        category_story_points = defaultdict(float)
        total_story_points = 0

        for issue in issues:
            fields = issue.get('fields', {})
            status_info = fields.get('status', {})
            status_name = status_info.get('name', 'Unknown')
            status_category = status_info.get('statusCategory', {}).get('key', '')

            # Accumulate story points
            story_points = fields.get('customfield_10061', 0)
            points_value = 0
            if story_points:
                try:
                    points_value = float(story_points)
                    total_story_points += points_value
                except (ValueError, TypeError):
                    pass

            # Sprint-specific categorization with separate verification category
            if status_name in ['In Review', 'Pending Review', 'Pending Verification', 'Pending Closure', 'Pending Deploy', 'Pending Merge']:
                categories['verification'].append(issue)
                status_counts['verification'] += 1
                category_story_points['verification'] += points_value
            elif status_category == 'done' or status_name == 'Abandoned':
                categories['done'].append(issue)
                status_counts['done'] += 1
                category_story_points['done'] += points_value
            elif 'blocked' in status_name.lower():
                categories['blocked'].append(issue)
                status_counts['blocked'] += 1
                category_story_points['blocked'] += points_value
            elif status_name in ['In Progress']:
                categories['in_progress'].append(issue)
                status_counts['in_progress'] += 1
                category_story_points['in_progress'] += points_value
            else:
                # Everything else goes to TO-DO
                categories['todo'].append(issue)
                status_counts['todo'] += 1
                category_story_points['todo'] += points_value

        categories = dict(categories)
        status_counts = dict(status_counts)

        # Show header with total count and sprint state
        total_tickets = len(issues)
        # Format story points as integer if whole number
        if total_story_points == int(total_story_points):
            pts_str = f"{int(total_story_points)} pts"
        else:
            pts_str = f"{total_story_points} pts"
        state_suffix = f" [{sprint_state}]" if sprint_state else ""
        print(f"{sprint_header}{state_suffix} ({total_tickets} tickets, {pts_str})")

        # Show sprint start and end dates with relative time
        if sprint_start_date or sprint_end_date:
            date_line = self.format_sprint_dates(sprint_start_date, sprint_end_date, use_colors)
            if date_line:
                print(date_line)

        print("=" * 60)
        print()

        # Sort all tickets by most recently updated within each category
        def sort_by_updated(tickets):
            def get_updated_sort_key(ticket):
                fields = ticket.get('fields', {})
                updated_str = fields.get('updated', '')
                try:
                    if updated_str.count(':') == 2 and ('+' in updated_str[-5:] or '-' in updated_str[-5:]):
                        updated_str = updated_str[:-2] + ':' + updated_str[-2:]
                    updated_dt = datetime.fromisoformat(updated_str)
                    return updated_dt
                except:
                    return datetime.min.replace(tzinfo=timezone.utc)
            return sorted(tickets, key=get_updated_sort_key, reverse=True)

        # Display sections with counts and all tickets
        for section_name, section_key in [
            ('BLOCKED', 'blocked'),
            ('TO-DO', 'todo'),
            ('IN PROGRESS', 'in_progress'),
            ('VERIFICATION', 'verification'),
            ('DONE', 'done')
        ]:
            ticket_list = categories.get(section_key, [])
            count = status_counts.get(section_key, 0)
            section_points = category_story_points.get(section_key, 0)

            if ticket_list:
                # Format story points as integer if whole number
                if section_points == int(section_points):
                    pts_str = f"{int(section_points)} pts"
                else:
                    pts_str = f"{section_points} pts"
                # Format ticket count
                ticket_str = "ticket" if count == 1 else "tickets"
                print(f"{section_name} ({count} {ticket_str}, {pts_str}):")
                # Sort by most recently updated and format all tickets
                sorted_tickets = sort_by_updated(ticket_list)
                for i, ticket in enumerate(sorted_tickets, 1):
                    # Use shared formatting function with status indicator
                    line = self.utils.format_ticket_line(ticket, i, summary_length, use_colors,
                                                       show_status=True, show_asterisk=True,
                                                       sprint_name=sprint_name)
                    print(f'   {line}')
                print()

    def sort_backlog_by_rank(self, issues: List[dict]) -> List[dict]:
        """Sort issues by Jira rank field (customfield_10022)."""
        def get_rank_sort_key(issue):
            fields = issue.get('fields', {})
            rank = fields.get('customfield_10022', '')

            if rank and '|' in rank and ':' in rank:
                # Extract rank part after pipe: 'hzzwg1:000i'
                rank_part = rank.split('|')[1]
                if ':' in rank_part:
                    prefix, suffix = rank_part.split(':', 1)
                    # For Jira rank ordering, treat as pure string comparison
                    # Jira's rank values are designed to sort lexicographically
                    suffix_clean = suffix.rstrip(':')
                    return (prefix, suffix_clean)

            # Fallback to issue key for consistent ordering
            issue_key = issue.get('key', 'ZZZZ-9999')
            issue_num = issue_key.split('-')[-1] if '-' in issue_key else '9999'
            return ('zzz_fallback', issue_num.zfill(10))

        return sorted(issues, key=get_rank_sort_key)

    def show_backlog(self, backlog_jql: str, count: int, summary_length: int, use_colors: bool) -> None:
        """Show top backlog items with status indicators."""
        print(f">> TOP BACKLOG (Next {count} items)")
        print("=" * 40)

        self.utils.print_status_legend(use_colors, 'backlog')
        print()

        # Query Jira for ALL backlog tickets using nextPageToken pagination
        jql_encoded = backlog_jql.replace(' ', '%20')
        all_issues = []
        next_page_token = None
        max_results = 100

        while True:
            # Build endpoint with nextPageToken if we have one
            if next_page_token:
                endpoint = f"/search/jql?jql={jql_encoded}&fields=key,summary,priority,created,assignee,customfield_10061,customfield_10022,status,updated,duedate&maxResults={max_results}&nextPageToken={next_page_token}"
            else:
                endpoint = f"/search/jql?jql={jql_encoded}&fields=key,summary,priority,created,assignee,customfield_10061,customfield_10022,status,updated,duedate&maxResults={max_results}"

            response = self.utils.call_jira_api(endpoint)
            if not response:
                print("❌ Failed to fetch backlog data")
                return

            issues = response.get('issues', [])
            next_page_token = response.get('nextPageToken')

            # If no issues returned, we're done
            if not issues:
                break

            all_issues.extend(issues)

            # If no nextPageToken, we're on the last page
            if not next_page_token:
                break

            # Safety limit to prevent runaway queries
            if len(all_issues) > 1000:
                break

        if not all_issues:
            print("   No backlog items found")
            return

        # Sort by rank and limit to requested count
        issues_sorted = self.sort_backlog_by_rank(all_issues)
        limited_issues = issues_sorted[:count]

        for i, issue in enumerate(limited_issues, 1):
            # Use shared formatting function
            line = self.utils.format_ticket_line(issue, i, summary_length, use_colors, show_status=True)
            print(f' {line}')

        if len(issues_sorted) > count:
            print(f'   ... and {len(issues_sorted) - count} more items in backlog')

    def run(self, args) -> None:
        """Main dashboard execution."""
        # Check if jira-api script exists
        if not self.utils.jira_api.exists() or not os.access(self.utils.jira_api, os.X_OK):
            print(f"❌ Error: jira-api script not found at {self.utils.jira_api}", file=sys.stderr)
            sys.exit(1)

        # Handle list teams
        if args.list_teams:
            self.utils.list_teams(self.config_file)
            return

        # Load team configuration
        try:
            team_config = self.utils.load_team_config(args.team, self.config_file)
        except (FileNotFoundError, ValueError) as e:
            print(f"❌ Error: {e}", file=sys.stderr)
            print("Available teams:", file=sys.stderr)
            self.utils.list_teams(self.config_file)
            sys.exit(1)

        # Build sprint JQL from projects and sprint name
        projects = team_config.get('projects', '')
        display_name = team_config['display_name']

        if not projects:
            print(f"❌ Error: Team '{args.team}' missing 'projects' field in config", file=sys.stderr)
            sys.exit(1)

        # Determine sprint name (command line override > config > auto-detect)
        sprint_name = None
        if hasattr(args, 'sprint') and args.sprint:
            # Command line override
            sprint_name = args.sprint
        elif team_config.get('sprint_name'):
            # Configured sprint name
            sprint_name = team_config['sprint_name']
        else:
            # Auto-detect using find-current-sprint
            first_project = projects.split(',')[0].strip()
            try:
                find_sprint_cmd = [str(self.script_dir / "find-current-sprint"), first_project]
                result = subprocess.run(find_sprint_cmd, capture_output=True, text=True, timeout=10)
                if result.returncode == 0:
                    sprint_name = result.stdout.strip()
                else:
                    sprint_name = f"{first_project} Current Sprint"
            except Exception:
                sprint_name = f"{first_project} Current Sprint"

        # Build sprint JQL
        sprint_jql = f'project IN ({projects}) AND sprint = "{sprint_name}"'

        # Build backlog JQL from projects or use configured backlog_jql
        if team_config.get('backlog_jql'):
            backlog_jql = team_config['backlog_jql']
        else:
            # Use default project-based backlog query
            backlog_jql = f'project IN ({projects}) AND sprint is EMPTY AND statusCategory != Done AND type not in (Deploy, Request)'

        # Modify JQL to include or exclude deferred tickets
        if hasattr(args, 'include_deferred') and args.include_deferred:
            backlog_jql = backlog_jql.replace(' AND status != Deferred', '')
        else:
            if 'status != Deferred' not in backlog_jql:
                backlog_jql += ' AND status != Deferred'

        # Calculate summary length based on terminal width
        terminal_width = self.utils.get_terminal_width()
        calculated_summary_length = self.utils.calculate_summary_length(terminal_width, args.length)

        # Determine if colors should be used
        use_colors = self.utils.determine_colors(args)

        # Display header
        print(f"{display_name} Dashboard - {datetime.now().strftime('%Y-%m-%d %H:%M')} [Width: {terminal_width}, Summary: {calculated_summary_length} chars]")
        print("=" * 50)
        print()

        # Show sprint status
        self.show_sprint_status(sprint_jql, calculated_summary_length, use_colors)
        print()

        # Show backlog
        self.show_backlog(backlog_jql, args.count, calculated_summary_length, use_colors)


def main():
    parser = argparse.ArgumentParser(description='Team dashboard showing current sprint and backlog')

    # Add standard arguments
    utils = JiraUtils()
    utils.add_common_arguments(parser, include_team=True, include_count=True,
                              default_count=10, include_deferred=True)

    # Add team-dashboard specific arguments
    parser.add_argument('-s', '--sprint', help='Specify sprint name (default: auto-detect current sprint)')

    args = parser.parse_args()

    dashboard = TeamDashboard()
    dashboard.run(args)


if __name__ == '__main__':
    main()