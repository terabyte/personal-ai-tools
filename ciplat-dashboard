#!/usr/bin/env bash

# CIPLAT Dashboard - Quick sprint and backlog overview
# Shows current sprint status and top backlog items

SELF="$(basename "$0")"
JIRA_API="$(dirname "$0")/jira-api"

function usage {
    cat <<EOF
$SELF: CIPLAT team dashboard showing current sprint and backlog

USAGE:
    $SELF [OPTIONS]

OPTIONS:
    -s, --sprint SPRINT    Specify sprint name (default: auto-detect current sprint)
    -n, --count N          Number of backlog items to show (default: 10)
    -h, --help            Show this help

EXAMPLES:
    $SELF                                    # Show current sprint + top backlog
    $SELF --sprint "CIPLAT 2025-10-07"     # Show specific sprint
    $SELF --count 5                         # Show only top 5 backlog items

EOF
}

function get_current_sprint {
    # Try to detect current sprint by looking for recently updated tickets with sprint info
    # This is a heuristic since we can't access sprint API directly
    local current_date=$(date +"%Y-%m-%d")
    echo "CIPLAT $(date -d "next monday" +"%Y-%m-%d" 2>/dev/null || echo "2025-10-07")"
}

function show_sprint_status {
    local sprint_name="$1"
    echo "ðŸŽ¯ CURRENT SPRINT: $sprint_name"
    echo "=" | head -c 60; echo

    # Get recent tickets and categorize by status
    local jql="project=CIPLAT AND updated >= -14d"
    local response=$($JIRA_API GET "/search/jql?jql=$(printf '%s' "$jql" | sed 's/ /%20/g')&fields=key,summary,status,assignee,priority,customfield_10061&maxResults=50" 2>/dev/null)

    if [[ $? -ne 0 ]] || [[ -z "$response" ]]; then
        echo "âŒ Failed to fetch sprint data"
        return 1
    fi

    # Parse and categorize by status
    echo "$response" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    issues = data.get('issues', [])

    # Group by status category
    blocked = []
    todo = []
    in_progress = []
    in_review = []
    done = []

    for issue in issues:
        fields = issue.get('fields', {})
        key = issue.get('key', 'N/A')  # Key is at top level, not in fields
        summary = fields.get('summary', 'No summary')[:50]
        status_info = fields.get('status', {})
        status_name = status_info.get('name', 'Unknown')
        status_category = status_info.get('statusCategory', {}).get('key', '')
        assignee = fields.get('assignee')
        # Try to get username first, fallback to display name
        if assignee:
            assignee_email = assignee.get('emailAddress', '')
            if assignee_email and '@' in assignee_email:
                assignee_name = assignee_email.split('@')[0]  # LDAP username
            else:
                assignee_name = assignee.get('displayName', '')
        else:
            assignee_name = ''

        story_points = fields.get('customfield_10061', 0) or 0  # Story points field
        # Format story points as integer if whole number, otherwise float
        if isinstance(story_points, (int, float)) and story_points == int(story_points):
            story_points_str = str(int(story_points))
        else:
            story_points_str = str(story_points)

        # Format: CIPLAT-1234 [3pt, User] or CIPLAT-1234 [3pt] if unassigned
        assignee_part = f', {assignee_name}' if assignee_name else ''
        item = f'{key} [{story_points_str}pt{assignee_part}]: {summary}...'

        # Categorize by status
        if 'blocked' in status_name.lower():
            blocked.append(item)
        elif status_category == 'new' or 'triage' in status_name.lower():
            todo.append(item)
        elif status_category == 'indeterminate' or 'progress' in status_name.lower():
            in_progress.append(item)
        elif 'review' in status_name.lower():
            in_review.append(item)
        elif status_category == 'done':
            done.append(item)
        else:
            todo.append(item)  # Default fallback

    # Display sections
    if blocked:
        print('ðŸš« BLOCKED:')
        for item in blocked[:5]: print(f'   {item}')
        print()

    if todo:
        print('ðŸ“‹ TO-DO:')
        for item in todo[:5]: print(f'   {item}')
        print()

    if in_progress:
        print('ðŸ”„ IN PROGRESS:')
        for item in in_progress[:5]: print(f'   {item}')
        print()

    if in_review:
        print('ðŸ‘€ IN REVIEW:')
        for item in in_review[:5]: print(f'   {item}')
        print()

    if done:
        print('âœ… RECENTLY DONE:')
        for item in done[:3]: print(f'   {item}')
        print()

except Exception as e:
    print(f'Error parsing sprint data: {e}')
"
}

function show_backlog {
    local count=${1:-10}
    echo "ðŸ“š TOP BACKLOG (Next $count items)"
    echo "=" | head -c 40; echo

    # Get backlog items - include both "Pending Triage" and "on Backlog" statuses
    # Get them in rank order using the rank field
    local jql="project=CIPLAT AND (status='Pending Triage' OR status='on Backlog')"
    local response=$($JIRA_API GET "/search/jql?jql=$(printf '%s' "$jql" | sed 's/ /%20/g')&fields=key,summary,priority,created,assignee,customfield_10061,customfield_10022&maxResults=100" 2>/dev/null)

    if [[ $? -ne 0 ]] || [[ -z "$response" ]]; then
        echo "âŒ Failed to fetch backlog data"
        return 1
    fi

    echo "$response" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    issues = data.get('issues', [])

    # Sort issues by rank field (customfield_10022) to get proper backlog order
    # Jira rank format is like '0|hzzwg1:2' or '0|i003pj:00ibi06020909'
    # The part after | contains prefix:suffix - we need to sort by prefix then suffix
    def get_rank_sort_key(issue):
        fields = issue.get('fields', {})
        rank = fields.get('customfield_10022', '')
        if rank and '|' in rank and ':' in rank:
            # Extract the rank part after the pipe: 'hzzwg1:2'
            rank_part = rank.split('|')[1]
            if ':' in rank_part:
                prefix, suffix = rank_part.split(':', 1)
                # Create a sort key that sorts by prefix first, then suffix
                # Pad numeric suffixes for proper ordering
                if suffix.rstrip(':').isdigit():
                    padded_suffix = suffix.rstrip(':').zfill(10)
                else:
                    padded_suffix = suffix.rstrip(':')
                return (prefix, padded_suffix)
        # Fallback to issue key for consistent ordering
        issue_key = issue.get('key', 'ZZZZ-9999')
        issue_num = issue_key.split('-')[-1] if '-' in issue_key else '9999'
        return ('zzz_fallback', issue_num.zfill(10))

    # Sort issues by rank
    issues_sorted = sorted(issues, key=get_rank_sort_key)

    # Limit to requested count
    count = $count
    limited_issues = issues_sorted[:count]

    for i, issue in enumerate(limited_issues, 1):
        fields = issue.get('fields', {})
        key = issue.get('key', 'N/A')  # Key is at top level, not in fields
        summary = fields.get('summary', 'No summary')[:50]
        priority = fields.get('priority', {}).get('name', 'No Priority')
        assignee = fields.get('assignee')
        # Try to get username first, fallback to display name
        if assignee:
            assignee_email = assignee.get('emailAddress', '')
            if assignee_email and '@' in assignee_email:
                assignee_name = assignee_email.split('@')[0]  # LDAP username
            else:
                assignee_name = assignee.get('displayName', '')
        else:
            assignee_name = ''

        story_points = fields.get('customfield_10061', 0) or 0  # Story points field
        # Format story points as integer if whole number, otherwise float
        if isinstance(story_points, (int, float)) and story_points == int(story_points):
            story_points_str = str(int(story_points))
        else:
            story_points_str = str(story_points)

        # Format: CIPLAT-1234 [3pt, User] or CIPLAT-1234 [3pt] if unassigned
        assignee_part = f', {assignee_name}' if assignee_name else ''
        print(f'{i:2d}. {key} [{story_points_str}pt{assignee_part}]: {summary}... [{priority}]')

    if not limited_issues:
        print('   No backlog items found in triage status')
    elif len(issues_sorted) > count:
        print(f'   ... and {len(issues_sorted) - count} more items in backlog')

except Exception as e:
    print(f'Error parsing backlog data: {e}')
"
}

function main {
    local sprint_name=""
    local backlog_count=10

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -s|--sprint)
                sprint_name="$2"
                shift 2
                ;;
            -n|--count)
                backlog_count="$2"
                shift 2
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                echo "Unknown option: $1" >&2
                usage
                exit 1
                ;;
        esac
    done

    # Check if jira-api script exists
    if [[ ! -x "$JIRA_API" ]]; then
        echo "âŒ Error: jira-api script not found at $JIRA_API" >&2
        exit 1
    fi

    # Get current sprint name if not provided
    if [[ -z "$sprint_name" ]]; then
        sprint_name=$(get_current_sprint)
    fi

    echo "CIPLAT Team Dashboard - $(date '+%Y-%m-%d %H:%M')"
    echo "=" | head -c 50; echo
    echo

    # Show sprint status
    show_sprint_status "$sprint_name"
    echo

    # Show backlog
    show_backlog "$backlog_count"
}

main "$@"